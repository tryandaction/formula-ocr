/**
 * 操作管理器
 * 负责处理单个公式的复制和编辑操作
 */

import type { FormulaInstance } from './types';
import { ClipboardManager } from './ClipboardManager';

/**
 * 操作管理器实现
 */
export class OperationManager {
  private clipboardManager: ClipboardManager;

  constructor() {
    this.clipboardManager = new ClipboardManager();
  }

  /**
   * 复制公式为LaTeX格式
   * 
   * @param formula - 公式实例
   * @returns 是否成功
   */
  async copyAsLatex(formula: FormulaInstance): Promise<boolean> {
    try {
      // 如果已经有LaTeX内容，直接复制
      if (formula.latexContent) {
        return await this.clipboardManager.copyText(formula.latexContent);
      }

      // 否则，需要先转换（这里简化处理，实际应该调用FormatConverter）
      const latex = this.generatePlaceholderLatex(formula);
      return await this.clipboardManager.copyText(latex);
    } catch (error) {
      console.error('Failed to copy as LaTeX:', error);
      return false;
    }
  }

  /**
   * 复制公式为Markdown格式
   * 
   * @param formula - 公式实例
   * @returns 是否成功
   */
  async copyAsMarkdown(formula: FormulaInstance): Promise<boolean> {
    try {
      // 如果已经有Markdown内容，直接复制
      if (formula.markdownContent) {
        return await this.clipboardManager.copyText(formula.markdownContent);
      }

      // 否则，需要先转换
      const markdown = this.generatePlaceholderMarkdown(formula);
      return await this.clipboardManager.copyText(markdown);
    } catch (error) {
      console.error('Failed to copy as Markdown:', error);
      return false;
    }
  }

  /**
   * 编辑公式
   * 
   * @param formula - 公式实例
   * @param newContent - 新的LaTeX或Markdown内容
   * @returns 更新后的公式实例
   */
  async editFormula(
    formula: FormulaInstance,
    newContent: string
  ): Promise<FormulaInstance> {
    // 判断内容格式（简化处理）
    const isLatex = newContent.includes('\\') || newContent.includes('{');
    
    // 创建更新后的公式实例
    const updated: FormulaInstance = {
      ...formula,
      detectionTimestamp: Date.now(), // 更新时间戳
    };

    if (isLatex) {
      updated.latexContent = newContent;
      // 可以同时更新Markdown（这里简化处理）
      updated.markdownContent = `$${newContent}$`;
    } else {
      updated.markdownContent = newContent;
    }

    return updated;
  }

  /**
   * 批量导出公式
   * 
   * @param formulas - 公式实例数组
   * @param format - 导出格式
   * @returns 导出内容
   */
  exportFormulas(
    formulas: FormulaInstance[],
    format: 'latex' | 'markdown' | 'json'
  ): string {
    switch (format) {
      case 'latex':
        return this.exportAsLatex(formulas);
      case 'markdown':
        return this.exportAsMarkdown(formulas);
      case 'json':
        return this.exportAsJson(formulas);
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  /**
   * 导出为LaTeX格式
   */
  private exportAsLatex(formulas: FormulaInstance[]): string {
    const lines: string[] = [];
    
    lines.push('% Exported Formulas');
    lines.push('% Generated by Formula OCR System');
    lines.push('');
    
    formulas.forEach((formula, index) => {
      lines.push(`% Formula ${index + 1} (Page ${formula.pageNumber}, Confidence: ${(formula.confidence * 100).toFixed(1)}%)`);
      
      const latex = formula.latexContent || this.generatePlaceholderLatex(formula);
      
      if (formula.type === 'display' || formula.type === 'numbered') {
        lines.push('\\begin{equation}');
        lines.push(`  ${latex}`);
        lines.push('\\end{equation}');
      } else {
        lines.push(`$${latex}$`);
      }
      
      lines.push('');
    });
    
    return lines.join('\n');
  }

  /**
   * 导出为Markdown格式
   */
  private exportAsMarkdown(formulas: FormulaInstance[]): string {
    const lines: string[] = [];
    
    lines.push('# Exported Formulas');
    lines.push('');
    lines.push('Generated by Formula OCR System');
    lines.push('');
    
    formulas.forEach((formula, index) => {
      lines.push(`## Formula ${index + 1}`);
      lines.push('');
      lines.push(`- **Page**: ${formula.pageNumber}`);
      lines.push(`- **Type**: ${formula.type}`);
      lines.push(`- **Confidence**: ${(formula.confidence * 100).toFixed(1)}%`);
      lines.push('');
      
      const markdown = formula.markdownContent || this.generatePlaceholderMarkdown(formula);
      
      if (formula.type === 'display' || formula.type === 'numbered') {
        lines.push('$$');
        lines.push(markdown);
        lines.push('$$');
      } else {
        lines.push(`$${markdown}$`);
      }
      
      lines.push('');
    });
    
    return lines.join('\n');
  }

  /**
   * 导出为JSON格式
   */
  private exportAsJson(formulas: FormulaInstance[]): string {
    const exportData = {
      metadata: {
        exportDate: new Date().toISOString(),
        totalFormulas: formulas.length,
        generator: 'Formula OCR System',
      },
      formulas: formulas.map(formula => ({
        id: formula.id,
        pageNumber: formula.pageNumber,
        type: formula.type,
        confidence: formula.confidence,
        boundingBox: formula.boundingBox,
        latexContent: formula.latexContent,
        markdownContent: formula.markdownContent,
        metadata: formula.metadata,
      })),
    };
    
    return JSON.stringify(exportData, null, 2);
  }

  /**
   * 生成占位符LaTeX内容
   * 当公式尚未转换时使用
   */
  private generatePlaceholderLatex(formula: FormulaInstance): string {
    // 基于元数据生成简单的占位符
    const parts: string[] = [];
    
    if (formula.metadata.hasFraction) {
      parts.push('\\frac{a}{b}');
    }
    if (formula.metadata.hasIntegral) {
      parts.push('\\int');
    }
    if (formula.metadata.hasSummation) {
      parts.push('\\sum');
    }
    if (formula.metadata.hasSuperscript) {
      parts.push('x^{n}');
    }
    if (formula.metadata.hasSubscript) {
      parts.push('x_{i}');
    }
    
    if (parts.length === 0) {
      return '[Formula not yet converted]';
    }
    
    return parts.join(' ');
  }

  /**
   * 生成占位符Markdown内容
   * 当公式尚未转换时使用
   */
  private generatePlaceholderMarkdown(formula: FormulaInstance): string {
    // Markdown数学语法与LaTeX相同
    return this.generatePlaceholderLatex(formula);
  }
}
